<!doctype html>
<html lang="en">
<head>
  <meta charset="utf-8" />
  <meta name="viewport" content="width=device-width, initial-scale=1" />
  <title>WS Assigner — Identical + 2 rows per line (STEALTH v2025.9.2 EN — focus/scroll + theme + high-contrast day + scan-keep-focus)</title>

  <style>
    /* ===== Theme tokens (Night = default) ===== */
    :root{
      --bg:#0b0f14; --panel:#0f1623; --card:#121a2a; --text:#e6edf7; --muted:#8aa2c0;
      --accent:#0ca678; --accent2:#7aa2f7; --border:#1c2a40; --bad:#ff6b6b; --ok:#25d07c;
      --shadow-ring:#25d07c77; --shadow-strong:#7aa2f777;

      --pill-bg: color-mix(in oklab, var(--card) 92%, transparent);
      --pill-border: var(--border);
      --pill-text: var(--muted);
      --pill-free-bg: color-mix(in oklab, #16a34a 12%, #ffffff 0%);
      --pill-free-text: #34d399;
      --pill-busy-bg: color-mix(in oklab, #60a5fa 12%, #ffffff 0%);
      --pill-busy-text: #93c5fd;
      --name-color: var(--ok);
    }

    /* ===== Day mode (alto contraste, sin amarillos sobre blanco) ===== */
    .theme-day{
      --bg:#f7fbff; --panel:#eef5ff; --card:#ffffff; --text:#0a1726; --muted:#23405b;
      --accent:#0a8a63; --accent2:#1e3a8a; --border:#9fb8d6; --bad:#c81e1e; --ok:#0a7a43;
      --shadow-ring:#1e3a8a55; --shadow-strong:#1e3a8a66;

      --pill-bg:#f3f7ff;
      --pill-border:#c9d9f0;
      --pill-text:#1b3550;

      --pill-free-bg:#e8f6ee;
      --pill-free-text:#0a7a43;
      --pill-busy-bg:#eaf1ff;
      --pill-busy-text:#1e3a8a;

      --name-color:#0a7a43;
    }

    html,body{margin:0;background:var(--bg);color:var(--text);font:14px/1.5 system-ui,Segoe UI,Roboto,Inter,sans-serif;}
    .wrap{max-width:1200px;margin:24px auto;padding:0 16px;}
    .top{display:flex;flex-wrap:wrap;gap:8px;align-items:center;justify-content:space-between;margin-bottom:14px;}
    .group{display:flex;gap:8px;align-items:center;flex-wrap:wrap;}

    .pill{
      background:var(--pill-bg);
      border:1px solid var(--pill-border);
      border-radius:999px;
      padding:6px 10px;
      color:var(--pill-text);
    }

    .scan-in{
      height:40px;min-width:320px;padding:0 12px;border-radius:12px;
      border:1px solid var(--border);background:var(--card);color:var(--text);outline:none;
    }
    .scan-in::placeholder{color:var(--muted);}
    .scan-in:focus{box-shadow:0 0 0 2px var(--accent);border-color:var(--accent);}

    .btn{
      padding:9px 14px;border-radius:12px;border:1px solid var(--border);background:var(--card);color:var(--text);cursor:pointer
    }
    .btn:hover{filter:brightness(1.12);}

    .grid{display:grid;grid-template-columns:1fr;gap:16px;}
    .line{
      background:var(--panel);border:1px solid var(--border);border-radius:16px;padding:12px 12px;
      background-color: color-mix(in oklab, var(--panel) 85%, transparent);
    }
    .line h3{margin:0 0 12px 0;color:var(--muted);}
    .rows{display:grid;grid-template-rows:repeat(2, auto);gap:10px;}
    .stations-row{display:grid;gap:10px;}

    .station{
      position:relative;background:var(--card);border:1px solid var(--border);border-radius:14px;
      padding:12px 12px;min-height:96px;padding-bottom:74px;cursor:pointer;transition:.15s;
      background-color: color-mix(in oklab, var(--card) 90%, transparent);
      backdrop-filter: saturate(110%) blur(0.5px);
      outline:none;
      touch-action:none; /* helps pointer drag without scrolling */
    }
    .station:hover{transform:translateY(-1px);}
    .station:focus{box-shadow:0 0 0 3px var(--shadow-ring), 0 8px 24px -6px var(--shadow-strong);}

    .station .name{
      font-weight:600;opacity:.98;display:block;margin-bottom:8px;position:relative;z-index:2;color:var(--name-color);
      border:1px solid var(--border);border-radius:8px;padding:2px 10px;background:transparent;
      max-width: calc(100% - 64px); white-space:nowrap; overflow:hidden; text-overflow:ellipsis;
      line-height:1.25;
    }

    .station .meta{
      position:absolute;left:10px;bottom:8px;font-size:12px;color:var(--muted);z-index:1;
    }

    .station .pill{
      position:absolute;left:10px;bottom:30px;font-size:12px;padding:2px 8px;border-radius:8px;z-index:1;
      max-width:calc(100% - 20px);white-space:nowrap;overflow:hidden;text-overflow:ellipsis;
      background:var(--pill-bg); color:var(--pill-text); border:1px solid var(--pill-border);
    }
    .station.free .pill{ background:var(--pill-free-bg); color:var(--pill-free-text); border-color:color-mix(in oklab, var(--pill-free-text) 35%, #ffffff 0%); }
    .station.busy .pill{ background:var(--pill-busy-bg); color:var(--pill-busy-text); border-color:color-mix(in oklab, var(--pill-busy-text) 35%, #ffffff 0%); }

    .station.ws-target{outline:2px solid var(--accent);box-shadow:0 0 12px #25d07c55;}

    .toast{position:fixed;right:16px;bottom:16px;background:var(--card);border:1px solid var(--border);padding:10px 12px;border-radius:12px;opacity:.97}

    select.pill{background:var(--pill-bg);border:1px solid var(--pill-border);color:var(--pill-text);padding:6px 10px;border-radius:999px;outline:none}

    .station .avatar{
      position:absolute;right:10px;top:8px;width:44px;height:44px;border-radius:9999px;border:1px solid var(--border);object-fit:cover;display:none;background:#0e1524
    }
    .station.busy .avatar{display:block}
    .station.busy .name{padding-right:80px}

    /* Login bien en la esquina inferior derecha */
    .station .login-tag{
      position:absolute;left:auto;right:10px;top:auto;bottom:10px;
      font-size:12px;padding:2px 8px;border-radius:8px;border:1px solid var(--border);
      background:var(--pill-bg);color:var(--accent2);cursor:pointer;display:none;z-index:3;
      pointer-events:auto;max-width:calc(100% - 20px);white-space:nowrap;overflow:hidden;text-overflow:ellipsis
    }
    .station.busy .login-tag{display:inline-block}

    @keyframes flashPop{
      0%{ transform:scale(0.98); box-shadow:0 0 0 0 rgba(122,162,247,0.45) }
      60%{ transform:scale(1.02); box-shadow:0 0 0 10px rgba(122,162,247,0.00) }
      100%{ transform:scale(1.00); box-shadow:0 0 0 0 rgba(122,162,247,0.00) }
    }
    .station.just-assigned{ animation: flashPop 700ms ease-out; }

    @keyframes neonPulseBlueStrong{
      0%{box-shadow:0 0 0 2px rgba(122,162,247,0.5),0 0 16px rgba(122,162,247,0.45),0 0 32px rgba(122,162,247,0.35)}
      100%{box-shadow:0 0 0 3px rgba(122,162,247,0.8),0 0 26px rgba(122,162,247,0.65),0 0 58px rgba(122,162,247,0.50)}
    }
    .station.neon-last{
      outline:2px solid var(--accent2) !important;border-radius:12px;
      animation:neonPulseBlueStrong 1.4s ease-in-out infinite alternate !important;
      box-shadow:0 0 0 2px rgba(122,162,247,0.6),0 0 22px rgba(122,162,247,0.55),0 0 48px rgba(122,162,247,0.40) !important
    }

    *,*::before,*::after{ box-sizing:border-box; }
    html,body{ max-width:100%; overflow-x:hidden; }
    .wrap{ max-width:100%; width:100%; }
    .grid{ gap:12px; overflow-x:visible; }
    .line{ padding:10px; overflow-x:visible; }
    :root{ --station-min: 260px; }

    /* ===== Drag & Drop (Swap Mode) UI ===== */
    body.dragging *{ cursor: grabbing !important; }
    .station.drag-src{
      outline:2px solid var(--accent2) !important;
      box-shadow: 0 0 0 3px var(--shadow-strong), 0 10px 26px -10px var(--shadow-strong) !important;
      transform: translateY(-2px);
    }
    .station.drag-over{
      outline:2px dashed var(--accent) !important;
      box-shadow: 0 0 0 3px var(--shadow-ring), 0 10px 26px -10px var(--shadow-ring) !important;
    }
    .drag-ghost{
      position:fixed; left:0; top:0; transform: translate(-9999px, -9999px);
      pointer-events:none; z-index:999999;
      background: color-mix(in oklab, var(--card) 92%, transparent);
      border:1px solid var(--border);
      border-radius:14px;
      padding:10px 12px;
      min-width:260px;
      box-shadow: 0 10px 30px -10px rgba(0,0,0,.55);
      opacity:.98;
      backdrop-filter: blur(2px) saturate(115%);
    }
    .drag-ghost .g-title{ font-weight:700; color:var(--text); }
    .drag-ghost .g-sub{ font-size:12px; color:var(--muted); margin-top:2px; }
    .drag-ghost .g-pill{
      display:inline-block; margin-top:8px;
      font-size:12px; padding:2px 8px; border-radius:8px;
      border:1px solid var(--pill-border);
      background:var(--pill-bg); color:var(--pill-text);
      max-width: 360px; white-space:nowrap; overflow:hidden; text-overflow:ellipsis;
    }
  </style>
</head>

<body>
  <div class="wrap">
    <div class="top">
      <div class="group">
        <span class="pill">Total: <b id="totalCount">—</b></span>
        <span class="pill">Occupied: <b id="occCount">—</b></span>
        <span class="pill">Next free: <b id="nextFree">—</b></span>
        <span class="pill" id="bridgeStatus">Bridge: <b>waiting…</b></span>
        <span class="pill" id="stealthStatus" title="The FCLM window is reused and kept off-screen.">Stealth: <b>on</b></span>
        <span class="pill" id="wakeStatus" title="Keeps the screen awake while this tab is open (Wake Lock + fallback).">Awake: <b>starting…</b></span>
      </div>
      <div class="group">
        <input id="badge" class="scan-in" placeholder="Scan badge and press Enter" autofocus />
        <button id="openLink" class="btn">Open FCLM</button>
        <!-- Strategy select se inserta después -->
        <button id="help" class="btn">Bridge Help</button>
        <button id="csv" class="btn">Export CSV</button>
        <button id="slack" class="btn">Copy Slack</button>
        <button id="reset" class="btn">Reset</button>
        <button id="themeToggle" class="btn" title="Toggle Day/Night">Theme: Night</button>
      </div>
    </div>

    <div id="grid" class="grid">
      <div class="line" data-line="1"><h3>Line 1</h3><div class="rows"><div class="stations-row left"></div><div class="stations-row right"></div></div></div>
      <div class="line" data-line="2"><h3>Line 2</h3><div class="rows"><div class="stations-row left"></div><div class="stations-row right"></div></div></div>
      <div class="line" data-line="3"><h3>Line 3</h3><div class="rows"><div class="stations-row left"></div><div class="stations-row right"></div></div></div>
    </div>
  </div>

  <!-- Lines extra fuera del grid (como tenías) -->
  <div class="line" data-line="4"><h3>Line 4 — Problem Solvers</h3>
    <div class="rows">
      <div class="stations-row left"></div>
      <div class="stations-row right"></div>
    </div>
  </div>
  <div class="line" data-line="5"><h3>Line 5 — Indirects</h3>
    <div class="rows">
      <div class="stations-row left"></div>
      <div class="stations-row right"></div>
    </div>
  </div>

  <div id="toast" class="toast" style="display:none"></div>

<script>
(() => {
  // ======= Layouts (IDENTICAL order + 2 rows per line) =======
  const LAYOUT = {
    "3": [["WS 3-2", "WS 3-1"], ["WS 3-4", "WS 3-3"], ["WS 3-6", "WS 3-5"], ["WS 3-8", "WS 3-7"],
          ["WS 3-10", "WS 3-9"], ["WS 3-12", "WS 3-11"], ["WS 3-14", "WS 3-13"], ["WS 3-16", "WS 3-15"]],
    "2": [["WS 2-2", "WS 2-1"], ["WS 2-4", "WS 2-3"], ["WS 2-6", "WS 2-5"], ["WS 2-8", "WS 2-7"],
          ["WS 2-10", "WS 2-9"], ["WS 2-12", "WS 2-11"], ["WS 2-14", "WS 2-13"], ["WS 2-16", "WS 2-15"],
          ["WS 2-18", "WS 2-17"], ["WS 2-20", "WS 2-19"]],
    "1": [["WS 1-2", "WS 1-1"], ["WS 1-4", "WS 1-3"], ["WS 1-6", "WS 1-5"], ["WS 1-8", "WS 1-7"],
          ["WS 1-10", "WS 1-9"], ["WS 1-12", "WS 1-11"], ["WS 1-14", "WS 1-13"], ["WS 1-16", "WS 1-15"],
          ["WS 1-18", "WS 1-17"], ["WS 1-20", "WS 1-19"]],
    "4": [['PS 2', 'PS 1'], ['PS 4', 'PS 3'], ['PS 6', 'PS 5'], ['PS 8', 'PS 7'], ['PS 10', 'PS 9'], ['PS 12', 'PS 11'], ['PS 14', 'PS 13'], ['PS 16', 'PS 15']],
    "5": [['Indirect 2', 'Indirect 1'], ['Indirect 4', 'Indirect 3'], ['Indirect 6', 'Indirect 5'], ['Indirect 8', 'Indirect 7'], ['Indirect 10', 'Indirect 9'], ['Indirect 12', 'Indirect 11'], ['Indirect 14', 'Indirect 13'], ['Indirect 16', 'Indirect 15']]
  };

  const STATIONS = [
    "WS 1-2","WS 1-4","WS 1-6","WS 1-8","WS 1-10","WS 1-12","WS 1-14","WS 1-16","WS 1-18","WS 1-20",
    "WS 1-1","WS 1-3","WS 1-5","WS 1-7","WS 1-9","WS 1-11","WS 1-13","WS 1-15","WS 1-17","WS 1-19",
    "WS 2-2","WS 2-4","WS 2-6","WS 2-8","WS 2-10","WS 2-12","WS 2-14","WS 2-16","WS 2-18","WS 2-20",
    "WS 2-1","WS 2-3","WS 2-5","WS 2-7","WS 2-9","WS 2-11","WS 2-13","WS 2-15","WS 2-17","WS 2-19",
    "WS 3-2","WS 3-4","WS 3-6","WS 3-8","WS 3-10","WS 3-12","WS 3-14","WS 3-16",
    "WS 3-1","WS 3-3","WS 3-5","WS 3-7","WS 3-9","WS 3-11","WS 3-13","WS 3-15",
    "PS 2", "PS 4", "PS 6", "PS 8", "PS 10", "PS 12", "PS 14", "PS 16",
    "PS 1", "PS 3", "PS 5", "PS 7", "PS 9", "PS 11", "PS 13", "PS 15",
    "Indirect 2", "Indirect 4", "Indirect 6", "Indirect 8", "Indirect 10", "Indirect 12", "Indirect 14", "Indirect 16",
    "Indirect 1", "Indirect 3", "Indirect 5", "Indirect 7", "Indirect 9", "Indirect 11", "Indirect 13", "Indirect 15"
  ];

  const LINE_ROW_COUNTS = {"1": 10, "2": 10, "3": 8, "4": 8, "5": 8};

  // ======= Theme toggle (persist) =======
  const THEME_KEY = 'ws_theme_pref_v1';
  function getTheme(){ try { return localStorage.getItem(THEME_KEY) || 'night'; } catch { return 'night'; } }
  function setTheme(v){
    try { localStorage.setItem(THEME_KEY, v); } catch {}
    const root = document.documentElement;
    if(v==='day'){ root.classList.add('theme-day'); } else { root.classList.remove('theme-day'); }
    const btn = document.getElementById('themeToggle');
    if(btn) btn.textContent = 'Theme: ' + (v==='day' ? 'Day' : 'Night');
  }
  setTheme(getTheme());
  window.addEventListener('DOMContentLoaded', () => {
    const tbtn = document.getElementById('themeToggle');
    if(tbtn){ tbtn.addEventListener('click', () => setTheme(getTheme()==='day' ? 'night' : 'day')); }
  });

  // ======= State =======
  const STORAGE = { ASSIGNS: 'ws_assignments_identical_2rows_v1', CACHE: 'ws_emp_cache_identical_2rows_v1' };
  function load(k, d){ try{ return JSON.parse(localStorage.getItem(k)||'') ?? d; }catch{ return d; } }
  function save(k, v){ localStorage.setItem(k, JSON.stringify(v)); }

  let assignments = load(STORAGE.ASSIGNS, []);
  let empCache    = load(STORAGE.CACHE,   {});
  let selectedStation = null;
  let pendingScan = null;
  let lastAssignedStation = null;

  // ======= STEALTH WINDOW =======
  let FCLM_WIN = null;
  function offscreenXY(){
    let L = (screen && typeof screen.availWidth==='number') ? (screen.availWidth + 200) : 99999;
    let T = (screen && typeof screen.availHeight==='number') ? (screen.availHeight + 200) : 99999;
    return {left:L, top:T};
  }
  function ensureBridgeWindow(){
    try{
      if (FCLM_WIN && !FCLM_WIN.closed) return FCLM_WIN;
      const p = offscreenXY();
      const features = 'popup=1,toolbar=0,location=0,status=0,menubar=0,scrollbars=1,resizable=1,width=120,height=90,left='+p.left+',top='+p.top;
      FCLM_WIN = window.open('about:blank', 'fclm_ws_assigner_bg', features);
      if (FCLM_WIN){
        try{ FCLM_WIN.blur(); }catch{}
        try{ FCLM_WIN.moveTo(p.left, p.top); }catch{}
        window.focus();
      }
      return FCLM_WIN;
    }catch(_){ return null; }
  }
  function stealthNavigate(url){
    const w = ensureBridgeWindow();
    if(w){
      try{ w.location.replace(url); }catch{ try{ w.location.href = url; }catch{} }
      for (let i=0; i<5; i++){
        setTimeout(()=>{ try{ w.blur(); }catch{}; try{ window.focus(); }catch{}; }, (i+1)*140);
      }
    }else{
      const p = offscreenXY();
      const wf = window.open(url, 'fclm_ws_assigner_bg', 'popup=1,toolbar=0,location=0,status=0,menubar=0,scrollbars=1,resizable=1,width=120,height=90,left='+p.left+',top='+p.top);
      try{ wf && wf.blur(); window.focus(); }catch{}
    }
  }
  function requirePopupGesture(){
    const ok = !!ensureBridgeWindow();
    if(!ok){ toast('Please allow pop-ups once to use the Bridge.'); }
  }

  // ======= Utils =======
  const $ = (s, r=document) => r.querySelector(s);
  const $all = (s, r=document) => Array.from(r.querySelectorAll(s));
  function toast(msg, ms=1600){ const t=$('#toast'); t.textContent=msg; t.style.display='block'; setTimeout(() => t.style.display='none', ms); }
  function isBusy(st){ return assignments.some(a => a.station === st); }
  function whoAt(st){ return assignments.find(a => a.station === st); }
  function nextFree(){ return STATIONS.find(s => !isBusy(s)) || null; }
  function pretty(rec){ if(rec.name) return rec.name; if(rec.login) return '('+rec.login+')'; return 'Badge '+(rec.badge||''); }

  function scrub(){
    assignments = assignments.filter(a => STATIONS.includes(a.station));
    assignments.sort((a,b) => new Date(b.ts) - new Date(a.ts));
    const seen = new Set(), dedup=[];
    for(const a of assignments){ if(seen.has(a.station)) continue; seen.add(a.station); dedup.push(a); }
    assignments = dedup; save(STORAGE.ASSIGNS, assignments);
  }

  // ====== Focus helpers ======
  function refocusBadge(delay=60){
    setTimeout(()=>{ const b = document.getElementById('badge'); if(b){ try{ b.focus(); }catch{} } }, delay);
  }
  function focusAndScrollStation(st){
    const el = document.querySelector('.station[data-station="'+st+'"]');
    if(!el) return;
    try{ el.scrollIntoView({ behavior:'smooth', block:'center', inline:'center' }); }catch{}
    refocusBadge(220);
  }

  // ===== Keep Awake (Wake Lock + fallback) =====
  const wakeEl = document.getElementById('wakeStatus');
  function setWakeText(html){ if(wakeEl) wakeEl.innerHTML = html; }
  let wakeLock = null;
  let wakeTimer = null;

  async function requestWake(){
    try{
      if(!('wakeLock' in navigator)){
        setWakeText('Awake: <b>fallback</b>');
        startWakeFallback();
        return;
      }
      wakeLock = await navigator.wakeLock.request('screen');
      setWakeText('Awake: <b>on</b>');
      stopWakeFallback();
      try{
        wakeLock.addEventListener('release', ()=>{
          if(document.visibilityState === 'visible'){
            setWakeText('Awake: <b>restarting…</b>');
            setTimeout(()=>requestWake(), 800);
          } else {
            setWakeText('Awake: <b>off</b>');
          }
        });
      }catch{}
    }catch(e){
      setWakeText('Awake: <b>fallback</b>');
      startWakeFallback();
    }
  }

  function startWakeFallback(){
    if(wakeTimer) return;
    wakeTimer = setInterval(()=>{
      if(document.visibilityState !== 'visible') return;
      const b = document.getElementById('badge');
      const ae = document.activeElement;
      const safe = (!ae || ae === document.body || ae === document.documentElement || ae.id === 'badge');
      if(b && safe){ try{ b.focus({preventScroll:true}); }catch{} }
    }, 25000);
  }
  function stopWakeFallback(){
    if(!wakeTimer) return;
    clearInterval(wakeTimer);
    wakeTimer = null;
  }
  document.addEventListener('visibilitychange', ()=>{ if(document.visibilityState==='visible') requestWake(); });
  window.addEventListener('focus', ()=> requestWake());
  requestWake();

  /* ===== Drag/Swap Mode (ALWAYS ENABLED, starts only when you MOVE) ===== */
  let dragState = { active:false, srcStation:null, overStation:null, pointerId:null, ghost:null };
  let dragPrimed = null; // {station,pointerId,x,y,moved}

  function stationElByName(st){
    try{ return document.querySelector('.station[data-station="'+CSS.escape(st)+'"]'); }
    catch{ return document.querySelector('.station[data-station="'+st.replace(/"/g,'\"')+'"]'); }
  }
  function clearDragClasses(){ $all('.station').forEach(el=>el.classList.remove('drag-src','drag-over')); }
  function escapeHtml(s){
    return String(s||'')
      .replaceAll('&','&amp;').replaceAll('<','&lt;').replaceAll('>','&gt;')
      .replaceAll('"','&quot;').replaceAll("'",'&#39;');
  }
  function createGhost(srcStation){
    const srcRec = whoAt(srcStation);
    const g = document.createElement('div');
    g.className = 'drag-ghost';
    const title = srcStation;
    const sub = srcRec ? (srcRec.name || srcRec.login || ('Badge ' + (srcRec.badge||''))) : 'Free';
    const ptxt = srcRec ? 'Dragging assigned associate' : 'Dragging empty slot';
    g.innerHTML = '<div class="g-title">'+escapeHtml(title)+'</div><div class="g-sub">'+escapeHtml(sub)+'</div><span class="g-pill">'+escapeHtml(ptxt)+'</span>';
    document.body.appendChild(g);
    return g;
  }
  function moveGhost(x,y){
    if(!dragState.ghost) return;
    const ox=18, oy=18;
    dragState.ghost.style.transform = 'translate('+Math.round(x+ox)+'px, '+Math.round(y+oy)+'px)';
  }
  function destroyGhost(){
    if(dragState.ghost && dragState.ghost.parentNode) dragState.ghost.parentNode.removeChild(dragState.ghost);
    dragState.ghost = null;
  }
  function stationFromPoint(x,y){
    const el = document.elementFromPoint(x,y);
    if(!el) return null;
    const stEl = el.closest && el.closest('.station');
    if(!stEl) return null;
    return stEl.dataset.station || null;
  }
  function swapStations(stA, stB){
    if(!stA || !stB || stA===stB) return false;
    const aRec = whoAt(stA) ? Object.assign({}, whoAt(stA)) : null;
    const bRec = whoAt(stB) ? Object.assign({}, whoAt(stB)) : null;
    const now = new Date().toISOString();
    if(!aRec && !bRec){ toast('Both stations are free.'); return false; }

    assignments = assignments.filter(x => x.station !== stA && x.station !== stB);
    if(aRec){ aRec.station=stB; aRec.ts=now; assignments.unshift(aRec); }
    if(bRec){ bRec.station=stA; bRec.ts=now; assignments.unshift(bRec); }
    save(STORAGE.ASSIGNS, assignments);

    lastAssignedStation = stB;
    render();
    highlightStation(stA); highlightStation(stB);
    focusAndScrollStation(stB); refocusBadge();

    if(aRec && bRec) toast('Swapped: '+stA+' ⇄ '+stB);
    else if(aRec && !bRec) toast('Moved: '+stA+' → '+stB);
    else if(!aRec && bRec) toast('Moved: '+stB+' → '+stA);
    return true;
  }
  function startDragFromStation(srcStation, pointerId, x, y){
    dragState.active=true; dragState.srcStation=srcStation; dragState.overStation=null; dragState.pointerId=pointerId;
    document.body.classList.add('dragging');
    clearDragClasses();
    const srcEl = stationElByName(srcStation);
    if(srcEl) srcEl.classList.add('drag-src');
    destroyGhost();
    dragState.ghost = createGhost(srcStation);
    moveGhost(x,y);
  }
  function updateDragOver(x,y){
    if(!dragState.active) return;
    moveGhost(x,y);
    const over = stationFromPoint(x,y);
    if(over !== dragState.overStation){
      dragState.overStation = over;
      $all('.station').forEach(el=>el.classList.remove('drag-over'));
      if(over && over !== dragState.srcStation){
        const overEl = stationElByName(over);
        if(overEl) overEl.classList.add('drag-over');
      }
    }
  }
  function endDrag(x,y){
    if(!dragState.active) return;
    const src = dragState.srcStation;
    const dst = stationFromPoint(x,y);

    document.body.classList.remove('dragging');
    clearDragClasses();
    destroyGhost();

    dragState.active=false; dragState.srcStation=null; dragState.overStation=null; dragState.pointerId=null;

    if(!dst || !src || dst===src){ toast('Drag canceled.'); refocusBadge(); return; }
    swapStations(src, dst);
  }
  function cancelDrag(){
    if(!dragState.active && !dragPrimed) return;
    document.body.classList.remove('dragging');
    clearDragClasses();
    destroyGhost();
    dragState.active=false; dragState.srcStation=null; dragState.overStation=null; dragState.pointerId=null;
    dragPrimed=null;
    toast('Drag canceled.'); refocusBadge();
  }
  window.addEventListener('keydown', (e)=>{ if(e.key==='Escape' && (dragState.active || dragPrimed)) cancelDrag(); }, true);

  // Robust global handlers: prevents "stuck" dragging if pointer leaves a station fast
  let dragWatchdog = null;
  function armDragWatchdog(){
    if(dragWatchdog) clearTimeout(dragWatchdog);
    dragWatchdog = setTimeout(()=>{ 
      if(dragState.active || dragPrimed){ 
        cancelDrag(); 
        toast('Drag reset (failsafe).'); 
      }
    }, 8000);
  }
  function disarmDragWatchdog(){
    if(!dragWatchdog) return;
    clearTimeout(dragWatchdog);
    dragWatchdog = null;
  }

  document.addEventListener('pointermove', (ev)=>{
    if(dragState.active){
      armDragWatchdog();
      if(dragState.pointerId !== null && ev.pointerId !== dragState.pointerId) return;
      updateDragOver(ev.clientX, ev.clientY);
    } else if(dragPrimed){
      armDragWatchdog();
      if(ev.pointerId !== dragPrimed.pointerId) return;
      const dx = ev.clientX - dragPrimed.x;
      const dy = ev.clientY - dragPrimed.y;
      const dist = Math.hypot(dx, dy);
      if(dist >= 6){ // more responsive
        dragPrimed.moved = true;
        startDragFromStation(dragPrimed.station, dragPrimed.pointerId, ev.clientX, ev.clientY);
      }
    }
  }, {passive:true});

  document.addEventListener('pointerup', (ev)=>{
    if(dragState.active){
      if(dragState.pointerId !== null && ev.pointerId !== dragState.pointerId) return;
      disarmDragWatchdog();
      endDrag(ev.clientX, ev.clientY);
      dragPrimed = null;
    } else if(dragPrimed){
      if(ev.pointerId !== dragPrimed.pointerId) return;
      disarmDragWatchdog();
      const st = dragPrimed.station;
      const moved = !!dragPrimed.moved;
      dragPrimed = null;
      if(!moved) onStationClick(st);
    }
  }, true);

  document.addEventListener('pointercancel', ()=>{
    if(dragState.active || dragPrimed){
      disarmDragWatchdog();
      cancelDrag();
    }
  }, true);

  window.addEventListener('blur', ()=>{
    if(dragState.active || dragPrimed){
      disarmDragWatchdog();
      cancelDrag();
    }
  });

  function onStationClick(name){
    if(selectedStation===name){ selectedStation=null; toast('Target canceled'); updateSel(); refocusBadge(); return; }
    selectedStation=name; toast('Target: ' + name + (isBusy(name)?' (occupied — swap)':'')); updateSel();
    const a = whoAt(name); if(a) announce(name, pretty(a));
    focusAndScrollStation(name);
  }

  function updateSel(){
    $all('.station').forEach(el => {
      const st=el.dataset.station;
      if(selectedStation===st) el.classList.add('ws-target'); else el.classList.remove('ws-target');
    });
  }

  function buildGrid(){
    Object.keys(LAYOUT).sort((a,b)=>Number(a)-Number(b)).forEach(line => {
      const leftNames  = (LAYOUT[line]||[]).map(p=>p[0]);
      const rightNames = (LAYOUT[line]||[]).map(p=>p[1]);
      const cols = ({"1":10,"2":10,"3":8,"4":8,"5":8}[line]||1);

      const lineEl = document.querySelector('.line[data-line="'+line+'"]');
      const leftRow  = lineEl.querySelector('.stations-row.left');
      const rightRow = lineEl.querySelector('.stations-row.right');
      leftRow.style.gridTemplateColumns  = 'repeat('+cols+', 1fr)';
      rightRow.style.gridTemplateColumns = 'repeat('+cols+', 1fr)';

      leftRow.innerHTML = ''; rightRow.innerHTML='';
      for(const name of leftNames){
        const el = document.createElement('div');
        el.className = 'station'; el.dataset.station = name; el.setAttribute('tabindex','-1');
        el.innerHTML = '<div class="name"></div><img class="avatar" alt=""><span class="pill"></span><span class="meta"></span><span class="login-tag" title="Click to copy login"></span>';
        leftRow.appendChild(el); bindStation(el, name);
      }
      for(const name of rightNames){
        const el = document.createElement('div');
        el.className = 'station'; el.dataset.station = name; el.setAttribute('tabindex','-1');
        el.innerHTML = '<div class="name"></div><img class="avatar" alt=""><span class="pill"></span><span class="meta"></span><span class="login-tag" title="Click to copy login"></span>';
        rightRow.appendChild(el); bindStation(el, name);
      }
    });
  }

  function bindStation(el, name){
    const nm = el.querySelector('.name');
    if(nm){
      nm.style.userSelect='text';
      nm.addEventListener('auxclick', (ev)=>{
        if(ev.button!==1) return;
        ev.stopPropagation(); ev.preventDefault();
        const a = whoAt(name);
        const val = a && a.login ? a.login : '';
        if(val){ navigator.clipboard.writeText(String(val)).then(()=>toast('Copied: ' + val)); }
      });
    }

    const tag = el.querySelector('.login-tag');
    if(tag){
      tag.addEventListener('click', (ev)=>{ ev.stopPropagation(); ev.preventDefault();
        const a = whoAt(name);
        let val = (a && a.login) ? a.login : (tag && tag.textContent ? tag.textContent : '');
        if(!val){ toast('No login'); return; }
        navigator.clipboard.writeText(String(val)).then(()=>toast('Copied: ' + val)).catch(()=>toast('Could not copy'));
      });
    }

    el.addEventListener('pointerdown', (ev) => {
      if(ev.button !== 0) return;
      if(ev.target && ev.target.closest && ev.target.closest('.login-tag')) return;
      dragPrimed = { station:name, pointerId: ev.pointerId, x: ev.clientX, y: ev.clientY, moved:false };
      try{ el.setPointerCapture(ev.pointerId); }catch{}
    });

    el.addEventListener('pointermove', ()=>{});

    el.addEventListener('pointerup', ()=>{});

    el.addEventListener('pointercancel', ()=> cancelDrag());
    el.addEventListener('contextmenu', (ev) => { ev.preventDefault(); freeStation(name); });
  }

  function render(){
    if(typeof lastAssignedStation!=='undefined' && lastAssignedStation){
      $all('.station').forEach(el=>el.classList.remove('neon-last'));
      const el = document.querySelector('.station[data-station="'+lastAssignedStation+'"]');
      if(el) el.classList.add('neon-last');
    }
    $('#totalCount').textContent = STATIONS.length;
    $('#occCount').textContent = assignments.length;
    const n = nextFree(); $('#nextFree').textContent = n || '—';

    $all('.station').forEach(el => {
      const st = el.dataset.station;
      el.querySelector('.name').textContent = st;
      const pill = el.querySelector('.pill');
      const meta = el.querySelector('.meta');
      const loginTag = el.querySelector('.login-tag');
      const avatar = el.querySelector('.avatar');
      const a = whoAt(st);
      if(a){
        el.classList.remove('free'); el.classList.add('busy');
        if(avatar){
          if(a.photo){
            avatar.src = a.photo;
            avatar.alt = (a.name||a.login||'Employee');
            avatar.style.display = 'block';
            avatar.onerror = ()=>{ avatar.style.display='none'; };
          } else {
            avatar.removeAttribute('src'); avatar.style.display = 'none';
          }
        }
        if(loginTag){ loginTag.textContent = a.login || ''; loginTag.style.display = (a.login?'inline-block':'none'); }
        pill.textContent = (a.name||a.login||('Badge '+a.badge));
        meta.textContent = new Date(a.ts).toLocaleTimeString();
      }else{
        el.classList.remove('busy'); el.classList.add('free');
        if(avatar){ avatar.removeAttribute('src'); avatar.style.display='none'; }
        if(loginTag){ loginTag.textContent=''; loginTag.style.display='none'; }
        pill.textContent = 'Free'; meta.textContent='';
      }
    });
  }

  function highlightStation(st){
    $all('.station').forEach(x=>x.classList.remove('neon-last'));
    const el = document.querySelector('.station[data-station="'+st+'"]');
    if(el){
      el.classList.add('neon-last');
      el.classList.add('just-assigned');
      setTimeout(()=>el.classList.remove('just-assigned'), 1200);
    }
  }

  function announce(st, who){
    try{ if(!('speechSynthesis' in window)) return; const u=new SpeechSynthesisUtterance(who+' to '+st); speechSynthesis.speak(u); }catch{}
  }

  function selectTargetOrNext(){
    const t = selectedStation || nextFree();
    if(!t){ toast('No free stations.'); return null; }
    return t;
  }

  function freeStation(st){
    const idx = assignments.findIndex(a => a.station===st);
    if(idx>=0){
      assignments.splice(idx,1);
      save(STORAGE.ASSIGNS, assignments);
      lastAssignedStation = st;
      render();
      highlightStation(st);
      focusAndScrollStation(st);
      refocusBadge();
      toast('Freed ' + st);
    }
  }

  function assignTo(st, badge, info=null){
    const existing = assignments.find(a=>a.station===st);
    const now = new Date().toISOString();
    if(existing){
      const nf = STATIONS.find(s => !isBusy(s) && s!==st);
      if(!nf){ toast('No free station available to swap'); return; }
      const idx = assignments.findIndex(a => a.station===st);
      const moved = Object.assign({}, assignments[idx], { station: nf, ts: now });
      const newcomer = { ts: now, badge: badge, name: (info && info.name) || '', login: (info && info.login) || '', emplId: (info && info.emplId) || '', photo: (info && info.photo) || '', station: st };
      assignments[idx] = newcomer;
      assignments.unshift(moved);
    } else {
      const rec = { ts: now, badge: badge, name: (info && info.name) || '', login: (info && info.login) || '', emplId: (info && info.emplId) || '', photo: (info && info.photo) || '', station: st };
      assignments.unshift(rec);
    }
    save(STORAGE.ASSIGNS, assignments);
    lastAssignedStation = st;
    render();
    highlightStation(st);
    focusAndScrollStation(st);
    refocusBadge();
    announce(st, (info && (info.name || info.login)) || ('Badge '+badge));
    selectedStation=null; updateSel();
  }

  // === OPEN FCLM (stealth) ===
  function openFCLMFor(token){
    try{
      const url = 'https://fclm-portal.amazon.com/employee/timeDetails?warehouseId=BFL2&employeeId=' + encodeURIComponent(token);
      stealthNavigate(url);
    }catch(e){}
  }

  function handleScanToken(raw){
    const token = String(raw||'').trim();
    if(!token){ toast('Empty badge'); return; }
    requirePopupGesture();
    try{
      const url = 'https://fclm-portal.amazon.com/employee/lookup?warehouseId=BFL2&employeeId='+encodeURIComponent(token);
      stealthNavigate(url);
    }catch{}
    const target = selectTargetOrNext(); if(!target) return;
    pendingScan = { tokenLower: token.toLowerCase(), timer: setTimeout(()=>{ if(pendingScan){ assignTo(target, token, null); pendingScan=null; } }, 2500) };
  }

  const $badge = document.getElementById('badge');
  $badge.addEventListener('keydown', (e)=>{
    if(e.key==='Enter' || e.key==='Tab'){
      e.preventDefault();
      document.getElementById('openLink') && document.getElementById('openLink').click();
    }
  });

  // ======= Captura global de escaneo (fallback) =======
  let scanBuf = '';
  let scanTimer = null;
  window.addEventListener('keydown', (e) => {
    if(dragState.active) return;
    const tgt = e.target;
    const isBadge = tgt && (tgt.id === 'badge');
    if(isBadge) return;

    if(e.key === 'Enter'){
      if(scanBuf.length >= 3){
        const b = document.getElementById('badge');
        if(b){
          b.value = scanBuf;
          document.getElementById('openLink') && document.getElementById('openLink').click();
          refocusBadge();
        }
        scanBuf = '';
        e.preventDefault();
      }
    }else if(e.key.length === 1 && !e.ctrlKey && !e.metaKey && !e.altKey){
      scanBuf += e.key;
      if(scanTimer) clearTimeout(scanTimer);
      scanTimer = setTimeout(()=>{ scanBuf=''; }, 500);
    }
  });

  window.addEventListener('message', (ev)=>{ try{
    const data = ev.data || {};
    if(data && data.type==='fclmEmployee'){
      document.getElementById('bridgeStatus').innerHTML = 'Bridge: <b>active</b>';
      if(data.badge) empCache[data.badge] = { name:data.name||'', login:data.login||'', emplId:data.emplId||'', photo:data.photo||'' };
      if(data.login) empCache[data.login] = { name:data.name||'', login:data.login||'', emplId:data.emplId||'', photo:data.photo||'' };
      save(STORAGE.CACHE, empCache);

      const info = { name:data.name||'', login:data.login||'', emplId:data.emplId||'', photo:data.photo||'' };
      let assigned=false;
      if(pendingScan){
        clearTimeout(pendingScan.timer);
        const t = selectTargetOrNext(); if(t) assignTo(t, data.badge||data.login||'', info);
        pendingScan=null; assigned=true;
      }
      if(!assigned){
        const exists = assignments.some(a=>a.badge===data.badge) || (data.login && assignments.some(a=>a.login===data.login));
        if(!exists){ const t = selectTargetOrNext(); if(t) assignTo(t, data.badge||data.login||'', info); }
      }
      refocusBadge();
      toast('Data received: '+(data.name||'—')+' ('+(data.login||'—')+')');
    }
  }catch(e){ console.warn(e); } });

  document.getElementById('csv').addEventListener('click', () => {
    const rows = [['timestamp','station','badge','name','login','emplId']].concat(assignments.map(a=>[a.ts,a.station,a.badge,a.name,a.login,a.emplId]));
    const csv = rows.map(r=>r.map(x=>'"'+String(x||'').replace(/"/g,'""')+'"').join(',')).join('\n');
    const blob = new Blob([csv],{type:'text/csv'}); const url=URL.createObjectURL(blob);
    const a = document.createElement('a'); a.href=url; a.download='ws-assignments.csv'; a.click(); setTimeout(()=>URL.revokeObjectURL(url), 2000);
  });

  document.getElementById('slack').addEventListener('click', () => {
    const lines = assignments.slice().reverse().map(a=>'• '+a.station+' — '+pretty(a));
    navigator.clipboard.writeText(lines.join('\n')).then(()=>toast('Copied to clipboard for Slack'));
  });

  document.getElementById('reset').addEventListener('click', () => {
    if(confirm('Reset all assignments?')){ assignments=[]; save(STORAGE.ASSIGNS, assignments); render(); refocusBadge(); }
  });

  document.getElementById('help').addEventListener('click', () => {
    alert('Install Tampermonkey and then the Bridge:\n1) Open the .user.js I gave you\n2) Accept the install\n3) Scan the badge here; FCLM opens in the background and the Bridge sends data back for auto-assign.');
  });

  document.getElementById('openLink').addEventListener('click', ()=>{
    const v=document.getElementById('badge').value.trim();
    if(!v){ toast('Enter login or badge'); return; }
    requirePopupGesture();
    openFCLMFor(v);
    setTimeout(()=>{ const b=document.getElementById('badge'); if(b){ b.value=''; b.focus(); } }, 0);
  });

  // ======= Estrategias =======
  const STRAT_KEY = 'ws_assign_strategy_v1';
  function getStrategy(){ try{ return localStorage.getItem(STRAT_KEY) || 'smartL1Cascade'; }catch{ return 'smartL1Cascade'; } }
  function setStrategy(v){ try{ localStorage.setItem(STRAT_KEY, v); }catch{} }

  function stationLine(st){ const m = /WS\s+(\d+)-/i.exec(String(st||'')); return m ? parseInt(m[1],10) : null; }
  function freeList(){ return STATIONS.filter(s => !isBusy(s)); }
  function freeByLine(line){ return freeList().filter(s => stationLine(s) === line); }
  function pickFirst(list){ return list.length ? list[0] : null; }
  function pickRandom(list){ return list.length ? list[Math.floor(Math.random()*list.length)] : null; }

  function nextFreeSmartTwoLines(lineA, lineB){
    const a = freeByLine(lineA);
    const b = freeByLine(lineB);
    return pickRandom(a) || pickRandom(b) || null;
  }

  function totalsByLine(){
    const lines = Array.from(new Set(STATIONS.map(stationLine).filter(Boolean)));
    const totals = {};
    for(const ln of lines){
      const total = STATIONS.filter(s => stationLine(s)===ln).length;
      const used  = assignments.filter(a => stationLine(a.station)===ln).length;
      totals[ln] = { total: total, used: used, free: total-used };
    }
    return totals;
  }

  function nextFreeBalance12(){
    const t = totalsByLine();
    const a = t[1] || {total:0, used:0}; const b = t[2] || {total:0, used:0};
    const occ1 = a.total ? a.used/a.total : 1;
    const occ2 = b.total ? b.used/b.total : 1;
    let target = null;
    if(occ1 < occ2) target = 1;
    else if(occ2 < occ1) target = 2;
    else target = 1;
    const cand = STATIONS.filter(s => stationLine(s)===target && !isBusy(s));
    return pickFirst(cand) || null;
  }
  function nextFreeRand12(){
    const list = freeList().filter(s => { const ln=stationLine(s); return ln===1 || ln===2; });
    return pickRandom(list) || null;
  }
  function nextFreeRandL1(){ return pickRandom(freeByLine(1)) || null; }
  function nextFreeRandAll(){ return pickRandom(freeList()) || null; }
  function nextFreeSmartCascade(startLine=1){
    const lines = [1,2,3];
    const order = [];
    for(let i=0;i<lines.length;i++){ order.push(((startLine-1+i)%lines.length)+1); }
    for(const ln of order){
      const pick = pickRandom(freeByLine(ln));
      if(pick) return pick;
    }
    return null;
  }

  (function initStrategyUI(){
    const openBtn = document.getElementById('openLink');
    if(!openBtn || document.getElementById('strategy')) return;
    const sel = document.createElement('select');
    sel.id = 'strategy';
    sel.className = 'pill';
    sel.title = 'Assignment strategy';
    sel.innerHTML = [
      ['sequential','Sequential (current)'],
      ['balance12','Balance L1↔L2'],
      ['rand12','Random L1↔L2'],
      ['randL1','Random only L1'],
      ['randAll','Random global'],
      ['smartL1Cascade','Smart random L1→L2→L3'],
      ['smart12','Smart random L1 & L2'],
      ['smart13','Smart random L1 & L3'],
    ].map(([v,t])=>'<option value="'+v+'">'+t+'</option>').join('');
    sel.value = getStrategy();
    sel.addEventListener('change', ()=> setStrategy(sel.value));
    openBtn.insertAdjacentElement('afterend', sel);
  })();

  const __orig_nextFree = nextFree;
  nextFree = function(){
    switch(getStrategy()){
      case 'balance12': return nextFreeBalance12() || __orig_nextFree();
      case 'rand12': return nextFreeRand12() || __orig_nextFree();
      case 'randL1': return nextFreeRandL1() || __orig_nextFree();
      case 'randAll': return nextFreeRandAll() || __orig_nextFree();
      case 'smartL1Cascade': return nextFreeSmartCascade(1) || __orig_nextFree();
      case 'smart12': return nextFreeSmartTwoLines(1,2) || __orig_nextFree();
      case 'smart13': return nextFreeSmartTwoLines(1,3) || __orig_nextFree();
      case 'sequential':
      default: return __orig_nextFree();
    }
  };

  // ===== Boot =====
  buildGrid(); scrub(); render();
  window.handleScanToken = handleScanToken;
})();
</script>
</body>
</html>
